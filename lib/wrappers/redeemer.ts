"use strict";
import BigNumber from "bignumber.js";
import {
  AggregatedEventsPayload,
  AggregateEventService,
  AggregateEventsFilter,
  EventToAggregate
} from "../aggregatedEventService";
import { Address, Hash } from "../commonTypes";
import { ContractWrapperBase } from "../contractWrapperBase";
import { ContractWrapperFactory } from "../contractWrapperFactory";
import { ArcTransactionResult, DecodedLogEntryEvent, IContractWrapperFactory } from "../iContractWrapperBase";
import { EventSubscription, IEventSubscription, PubSubEventService } from "../pubSubEventService";
import { TxGeneratingFunctionOptions } from "../transactionService";
import { Web3EventService } from "../web3EventService";
import { WrapperService } from "../wrapperService";
import { RedeemEventResult } from "./commonEventInterfaces";

export class RedeemerWrapper extends ContractWrapperBase {
  public name: string = "Redeemer";
  public friendlyName: string = "Redeemer";
  public factory: IContractWrapperFactory<RedeemerWrapper> = RedeemerFactory;

  /**
   * Redeems rewards for a ContributionReward proposal in a single transaction.
   * Calls execute on the proposal if it is not yet executed.
   * Redeems rewardable reputation and stake from the GenesisProtocol.
   * Redeem rewardable contribution proposal rewards.
   * @param options
   */
  public async redeem(options: RedeemerOptions & TxGeneratingFunctionOptions)
    : Promise<ArcTransactionResult> {

    if (!options.avatarAddress) {
      throw new Error("avatarAddress is not defined");
    }

    if (!options.beneficiaryAddress) {
      throw new Error("beneficiaryAddress is not defined");
    }

    if (!options.proposalId) {
      throw new Error("proposalId is not defined");
    }

    this.logContractFunctionCall("Redeemer.redeem", options);

    return this.wrapTransactionInvocation("Redeemer.redeem",
      options,
      this.contract.redeem,
      [options.proposalId, options.avatarAddress, options.beneficiaryAddress]
    );
  }

  /**
   * Returns the amounts that would be redeemed if `Redeemer.redeem` were invoked right now.
   * @param options
   */
  public async redeemables(options: RedeemerOptions)
    : Promise<RedeeemableResult> {

    if (!options.avatarAddress) {
      throw new Error("avatarAddress is not defined");
    }

    if (!options.beneficiaryAddress) {
      throw new Error("beneficiaryAddress is not defined");
    }

    if (!options.proposalId) {
      throw new Error("proposalId is not defined");
    }

    this.logContractFunctionCall("Redeemer.redeem.call", options);

    const result = await this.contract.redeem.call(
      options.proposalId,
      options.avatarAddress,
      options.beneficiaryAddress)
      // correct for fake truffle promises
      .then((r: any): any => r)
      .catch((ex: Error) => {
        throw new Error(ex.message);
      });

    return {
      contributionRewardEther: result[3][2],
      contributionRewardExternalToken: result[3][3],
      contributionRewardNativeToken: result[3][1],
      contributionRewardReputation: result[3][0],
      daoStakingBountyPotentialReward: result[1][1],
      daoStakingBountyReward: result[1][0],
      proposalExecuted: result[2],
      proposalId: options.proposalId,
      proposerReputationAmount: result[0][4],
      stakerReputationAmount: result[0][1],
      stakerTokenAmount: result[0][0],
      voterReputationAmount: result[0][3],
      voterTokenAmount: result[0][2],
    };
  }


  /**
   * Obtain an `EntityFetcherFactory` that enables you to get, watch and subscribe to events that
   * return a `RedeemerRewardEventsResult` when rewards are rewarded, either via `Redeemer.redeem`
   * or directly via `GenesisProtocol` and `ContributionReward`.
   *
   * The payload of the event,`RedeemerRewardsEventPayload`, provides information about the redemptions.
   *
   * You may subscribe to the events like this:
   *
   *   `PubSubService.subscribe(eventTopic, (topic: string, payload: RedeemerRewardsEventPayload) => { ... })`
   *
   * The events are aggregated from the logs of transactions occuring in each block in the
   * chain, as specified by the range of blocks given in the filter.
   *
   * Because these events are aggregated per transaction, while rewards generated by `Redeemer.redeem`
   * will result in a single event, rewards generated directly via `GenesisProtocol` and
   * `ContributionReward` will result in separate transactions and thus multiple individual events.
   *
   * @param eventTopic the name of the event to which you will subscribe for these events.
   * @param filter optionally provide `fromBlock` (default is "latest") and `toBlock` (optional).
   * If you don't supply `fromBlock`, or `fromBlock` is "latest'," then will start with the current block.
   * If you don't supply `toBlock`, or `toBlock` is "latest'," then will watch until unsubscribed.
   * @param requiredDepth -- If set then the event is not published until each transaction has been mined to
   * the requiredDepth. Pass -1 to use the Arc.js's global default depth.
   * @returns A subscription if the filter requires waiting for blocks that have not yet been mined.
   * If a subscription is returned you must unsubscribe to it when you are done with it,
   * or else the watch will continue forever.
   */
  public async rewardsEvents(
    eventTopic: string,
    filter?: AggregateEventsFilter,
    requiredDepth: number = 0): Promise<IEventSubscription> {

    const eventSpecifiersMap = new Map<EventToAggregate, string>();
    const genesisProtocol = WrapperService.wrappers.GenesisProtocol;
    const contributionReward = WrapperService.wrappers.ContributionReward;

    /* tslint:disable:max-line-length */
    eventSpecifiersMap.set({ eventName: "Redeem", contract: genesisProtocol }, "rewardGenesisProtocolTokens");
    eventSpecifiersMap.set({ eventName: "RedeemReputation", contract: genesisProtocol }, "rewardGenesisProtocolReputation");
    eventSpecifiersMap.set({ eventName: "RedeemDaoBounty", contract: genesisProtocol }, "bountyGenesisProtocolDao");
    eventSpecifiersMap.set({ eventName: "RedeemReputation", contract: contributionReward }, "rewardContributionReputation");
    eventSpecifiersMap.set({ eventName: "RedeemEther", contract: contributionReward }, "rewardContributionEther");
    eventSpecifiersMap.set({ eventName: "RedeemNativeToken", contract: contributionReward }, "rewardContributionNativeToken");
    eventSpecifiersMap.set({ eventName: "RedeemExternalToken", contract: contributionReward }, "rewardContributionExternalToken");
    /* tslint:enable:max-line-length */

    const aggregatorEventName = "Redeemer.aggregateEvents";

    const localSubscription =
      PubSubEventService.subscribe(aggregatorEventName, (topic: string, payload: AggregatedEventsPayload) => {

        const events: Array<DecodedLogEntryEvent<RedeemEventResult>> =
          Array.from(payload.events.values());

        const proposalId = events[0].args._proposalId;
        const result = {
          proposalId,
          transactionHash: payload.txReceipt.transactionHash,
        } as RedeemerRewardsEventPayload;

        /**
         * get all the reward amounts
         */
        for (const eventSpecifier of eventSpecifiersMap.keys()) {
          const event = payload.events.get(eventSpecifier) as DecodedLogEntryEvent<RedeemEventResult>;
          result[eventSpecifiersMap.get(eventSpecifier)] = event ? event.args._amount : new BigNumber(0);
        }

        /**
         * get the GP beneficiary, if there is one
         */
        for (const eventSpecifier of payload.events.keys()) {

          const propertyName = eventSpecifiersMap.get(eventSpecifier);

          if ([
            "rewardGenesisProtocolTokens",
            "rewardGenesisProtocolReputation",
            "bountyGenesisProtocolDao"].indexOf(propertyName) !== -1) {

            const event = payload.events.get(eventSpecifier) as DecodedLogEntryEvent<RedeemEventResult>;
            result.beneficiaryGenesisProtocol = event.args._beneficiary;
            break;
          }
        }

        /**
         * get the CR beneficiary, if there is one
         */
        for (const eventSpecifier of payload.events.keys()) {
          const propertyName = eventSpecifiersMap.get(eventSpecifier);

          if ([
            "rewardContributionReputation",
            "rewardContributionEther",
            "rewardContributionNativeToken",
            "rewardContributionExternalToken"].indexOf(propertyName) !== -1) {

            const event = payload.events.get(eventSpecifier) as DecodedLogEntryEvent<RedeemEventResult>;
            result.beneficiaryContributionReward = event.args._beneficiary;
            break;
          }
        }
        return PubSubEventService.publish(eventTopic, result);
      });

    // aggregatorSubscription is not necessarily defined
    const aggService = new AggregateEventService();

    const aggregatorSubscription = await aggService.aggregateEvents(
      Array.from(eventSpecifiersMap.keys()),
      aggregatorEventName,
      filter,
      requiredDepth);

    return new EventSubscription(eventTopic, (): Promise<void> => {
      return aggregatorSubscription ?
        aggregatorSubscription.unsubscribe().then(() => localSubscription.unsubscribe()) :
        localSubscription.unsubscribe();
    });
  }
}

/**
 * defined just to add good type checking
 */
export class RedeemerFactoryType extends ContractWrapperFactory<RedeemerWrapper> {

  public async new(
    contributionRewardAddress: Address,
    genesisProtocolAddress: Address): Promise<RedeemerWrapper> {
    return super.new(contributionRewardAddress, genesisProtocolAddress);
  }
}

export const RedeemerFactory =
  new RedeemerFactoryType(
    "Redeemer",
    RedeemerWrapper,
    new Web3EventService()) as RedeemerFactoryType;

export interface RedeeemableResult {
  contributionRewardEther: boolean;
  contributionRewardExternalToken: boolean;
  contributionRewardNativeToken: boolean;
  contributionRewardReputation: boolean;
  daoStakingBountyReward: BigNumber;
  daoStakingBountyPotentialReward: BigNumber;
  proposalExecuted: boolean;
  proposalId: Hash;
  proposerReputationAmount: BigNumber;
  stakerReputationAmount: BigNumber;
  stakerTokenAmount: BigNumber;
  voterReputationAmount: BigNumber;
  voterTokenAmount: BigNumber;
}

export interface RedeemerOptions {
  avatarAddress: Address;
  beneficiaryAddress: Address;
  proposalId: Hash;
}

export interface RedeemerRewardsEventPayload {
  beneficiaryGenesisProtocol: Address;
  beneficiaryContributionReward: Address;
  bountyGenesisProtocolDao: BigNumber;
  proposalId: Hash;
  rewardContributionEther: BigNumber;
  rewardContributionExternalToken: BigNumber;
  rewardContributionNativeToken: BigNumber;
  rewardContributionReputation: BigNumber;
  rewardGenesisProtocolTokens: BigNumber;
  rewardGenesisProtocolReputation: BigNumber;
  transactionHash: Hash;
}
